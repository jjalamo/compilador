
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Thu Aug 25 15:46:55 CEST 2016
//----------------------------------------------------

package compiler.syntax;

import java_cup.runtime.Symbol;
import java.util.*;
import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;
import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Thu Aug 25 15:46:55 CEST 2016
  */
public class parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\132\000\002\002\004\000\002\050\002\000\002\002" +
    "\004\000\002\051\002\000\002\003\011\000\002\004\005" +
    "\000\002\004\003\000\002\010\005\000\002\010\003\000" +
    "\002\011\005\000\002\011\003\000\002\012\004\000\002" +
    "\012\004\000\002\012\002\000\002\013\004\000\002\013" +
    "\003\000\002\014\006\000\002\015\003\000\002\015\003" +
    "\000\002\016\003\000\002\016\003\000\002\017\004\000" +
    "\002\017\003\000\002\020\010\000\002\026\004\000\002" +
    "\026\003\000\002\027\006\000\002\025\003\000\002\025" +
    "\003\000\002\025\004\000\002\021\004\000\002\021\003" +
    "\000\002\022\006\000\002\023\005\000\002\023\003\000" +
    "\002\024\003\000\002\024\003\000\002\052\002\000\002" +
    "\030\012\000\002\032\005\000\002\032\004\000\002\033" +
    "\005\000\002\033\003\000\002\034\005\000\002\053\002" +
    "\000\002\031\014\000\002\041\006\000\002\041\005\000" +
    "\002\036\005\000\002\036\003\000\002\035\003\000\002" +
    "\035\003\000\002\035\004\000\002\035\005\000\002\035" +
    "\006\000\002\035\004\000\002\035\006\000\002\035\003" +
    "\000\002\035\003\000\002\035\005\000\002\035\005\000" +
    "\002\035\005\000\002\035\005\000\002\035\005\000\002" +
    "\035\003\000\002\005\005\000\002\005\004\000\002\006" +
    "\004\000\002\006\003\000\002\007\003\000\002\007\003" +
    "\000\002\007\003\000\002\007\004\000\002\007\003\000" +
    "\002\037\006\000\002\040\003\000\002\040\004\000\002" +
    "\040\005\000\002\040\006\000\002\042\011\000\002\043" +
    "\004\000\002\043\003\000\002\047\004\000\002\047\002" +
    "\000\002\044\014\000\002\045\007\000\002\045\006\000" +
    "\002\046\003\000\002\046\003\000\002\046\002" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\262\000\004\024\000\001\002\000\004\002\264\001" +
    "\002\000\004\024\007\001\002\000\004\002\uffff\001\002" +
    "\000\004\006\010\001\002\000\004\040\011\001\002\000" +
    "\016\007\ufffe\011\ufffe\017\ufffe\023\ufffe\031\ufffe\032\ufffe" +
    "\001\002\000\016\007\ufff4\011\015\017\ufff4\023\ufff4\031" +
    "\021\032\013\001\002\000\004\006\055\001\002\000\004" +
    "\007\076\001\002\000\004\006\234\001\002\000\010\007" +
    "\ufff7\017\051\023\047\001\002\000\004\007\ufff9\001\002" +
    "\000\004\007\ufffb\001\002\000\004\006\022\001\002\000" +
    "\004\042\027\001\002\000\014\006\uffeb\007\uffeb\017\uffeb" +
    "\023\uffeb\032\uffeb\001\002\000\014\006\022\007\ufff4\017" +
    "\ufff4\023\ufff4\032\013\001\002\000\004\007\ufffa\001\002" +
    "\000\014\006\uffec\007\uffec\017\uffec\023\uffec\032\uffec\001" +
    "\002\000\004\025\030\001\002\000\004\006\031\001\002" +
    "\000\004\041\037\001\002\000\006\006\uffe8\014\uffe8\001" +
    "\002\000\006\006\031\014\035\001\002\000\006\006\uffe9" +
    "\014\uffe9\001\002\000\004\040\036\001\002\000\014\006" +
    "\uffea\007\uffea\017\uffea\023\uffea\032\uffea\001\002\000\010" +
    "\010\042\021\040\047\041\001\002\000\006\036\uffe6\040" +
    "\uffe6\001\002\000\004\021\045\001\002\000\006\036\uffe5" +
    "\040\uffe5\001\002\000\004\040\044\001\002\000\006\006" +
    "\uffe7\014\uffe7\001\002\000\006\036\uffe4\040\uffe4\001\002" +
    "\000\010\007\ufff5\017\ufff5\023\ufff5\001\002\000\004\006" +
    "\225\001\002\000\010\007\ufff6\017\ufff6\023\ufff6\001\002" +
    "\000\004\006\052\001\002\000\004\035\054\001\002\000" +
    "\004\041\071\001\002\000\006\006\055\036\061\001\002" +
    "\000\006\037\uffdf\041\uffdf\001\002\000\006\037\065\041" +
    "\066\001\002\000\006\036\062\040\063\001\002\000\006" +
    "\036\uffd7\040\uffd7\001\002\000\006\040\uffd9\041\uffd9\001" +
    "\002\000\006\040\uffda\041\uffda\001\002\000\004\006\055" +
    "\001\002\000\006\036\uffd8\040\uffd8\001\002\000\004\006" +
    "\070\001\002\000\010\010\042\021\040\047\041\001\002" +
    "\000\006\036\uffd6\040\uffd6\001\002\000\006\037\uffe0\041" +
    "\uffe0\001\002\000\010\010\042\021\040\047\041\001\002" +
    "\000\004\040\073\001\002\000\016\007\uffd5\011\uffd5\017" +
    "\uffd5\023\uffd5\031\uffd5\032\uffd5\001\002\000\016\007\ufff4" +
    "\011\015\017\ufff4\023\ufff4\031\021\032\013\001\002\000" +
    "\004\007\076\001\002\000\016\006\110\014\114\016\101" +
    "\020\107\033\111\034\104\001\002\000\004\040\100\001" +
    "\002\000\010\007\uffd4\017\uffd4\023\uffd4\001\002\000\004" +
    "\035\214\001\002\000\004\045\211\001\002\000\016\006" +
    "\uffbd\014\uffbd\016\uffbd\020\uffbd\033\uffbd\034\uffbd\001\002" +
    "\000\004\035\206\001\002\000\020\006\uffba\013\uffba\014" +
    "\uffba\016\uffba\020\uffba\033\uffba\034\uffba\001\002\000\020" +
    "\006\uffbc\013\uffbc\014\uffbc\016\uffbc\020\uffbc\033\uffbc\034" +
    "\uffbc\001\002\000\004\035\173\001\002\000\012\035\136" +
    "\045\uffb6\046\167\047\170\001\002\000\004\035\122\001" +
    "\002\000\020\006\uffb8\013\uffb8\014\uffb8\016\uffb8\020\uffb8" +
    "\033\uffb8\034\uffb8\001\002\000\016\006\110\014\121\016" +
    "\101\020\107\033\111\034\104\001\002\000\006\040\uffbf" +
    "\046\uffbf\001\002\000\020\006\uffbb\013\uffbb\014\uffbb\016" +
    "\uffbb\020\uffbb\033\uffbb\034\uffbb\001\002\000\004\040\117" +
    "\001\002\000\020\006\uffb9\013\uffb9\014\uffb9\016\uffb9\020" +
    "\uffb9\033\uffb9\034\uffb9\001\002\000\016\006\uffbe\014\uffbe" +
    "\016\uffbe\020\uffbe\033\uffbe\034\uffbe\001\002\000\006\040" +
    "\uffc0\046\uffc0\001\002\000\022\004\133\005\127\006\132" +
    "\015\130\030\126\035\123\036\uffa8\050\131\001\002\000" +
    "\016\004\133\006\132\015\130\030\126\035\123\050\131" +
    "\001\002\000\004\036\163\001\002\000\014\022\151\036" +
    "\uffaa\042\147\043\150\044\146\001\002\000\022\022\uffc8" +
    "\027\uffc8\036\uffc8\037\uffc8\040\uffc8\042\uffc8\043\uffc8\044" +
    "\uffc8\001\002\000\004\036\uffa9\001\002\000\022\022\uffc7" +
    "\027\uffc7\036\uffc7\037\uffc7\040\uffc7\042\uffc7\043\uffc7\044" +
    "\uffc7\001\002\000\004\006\160\001\002\000\030\022\uffce" +
    "\027\uffce\035\136\036\uffce\037\uffce\040\uffce\042\uffce\043" +
    "\uffce\044\uffce\046\135\047\137\001\002\000\022\022\uffcf" +
    "\027\uffcf\036\uffcf\037\uffcf\040\uffcf\042\uffcf\043\uffcf\044" +
    "\uffcf\001\002\000\022\022\uffc1\027\uffc1\036\uffc1\037\uffc1" +
    "\040\uffc1\042\uffc1\043\uffc1\044\uffc1\001\002\000\004\006" +
    "\156\001\002\000\020\004\133\006\132\015\130\030\126" +
    "\035\123\036\142\050\131\001\002\000\022\022\uffcd\027" +
    "\uffcd\036\uffcd\037\uffcd\040\uffcd\042\uffcd\043\uffcd\044\uffcd" +
    "\001\002\000\016\022\151\036\uffd0\037\uffd0\042\147\043" +
    "\150\044\146\001\002\000\006\036\144\037\143\001\002" +
    "\000\022\022\uffd2\027\uffd2\036\uffd2\037\uffd2\040\uffd2\042" +
    "\uffd2\043\uffd2\044\uffd2\001\002\000\016\004\133\006\132" +
    "\015\130\030\126\035\123\050\131\001\002\000\022\022" +
    "\uffd3\027\uffd3\036\uffd3\037\uffd3\040\uffd3\042\uffd3\043\uffd3" +
    "\044\uffd3\001\002\000\016\022\151\036\uffd1\037\uffd1\042" +
    "\147\043\150\044\146\001\002\000\016\004\133\006\132" +
    "\015\130\030\126\035\123\050\131\001\002\000\016\004" +
    "\133\006\132\015\130\030\126\035\123\050\131\001\002" +
    "\000\016\004\133\006\132\015\130\030\126\035\123\050" +
    "\131\001\002\000\016\004\133\006\132\015\130\030\126" +
    "\035\123\050\131\001\002\000\022\022\uffc5\027\uffc5\036" +
    "\uffc5\037\uffc5\040\uffc5\042\uffc5\043\uffc5\044\uffc5\001\002" +
    "\000\022\022\uffc6\027\uffc6\036\uffc6\037\uffc6\040\uffc6\042" +
    "\uffc6\043\uffc6\044\uffc6\001\002\000\016\022\151\027\uffc3" +
    "\036\uffc3\037\uffc3\040\uffc3\043\150\001\002\000\016\022" +
    "\151\027\uffc4\036\uffc4\037\uffc4\040\uffc4\043\150\001\002" +
    "\000\024\022\uffcc\027\uffcc\036\uffcc\037\uffcc\040\uffcc\042" +
    "\uffcc\043\uffcc\044\uffcc\047\157\001\002\000\022\022\uffcb" +
    "\027\uffcb\036\uffcb\037\uffcb\040\uffcb\042\uffcb\043\uffcb\044" +
    "\uffcb\001\002\000\024\022\uffca\027\uffca\036\uffca\037\uffca" +
    "\040\uffca\042\uffca\043\uffca\044\uffca\046\161\001\002\000" +
    "\004\006\162\001\002\000\022\022\uffc9\027\uffc9\036\uffc9" +
    "\037\uffc9\040\uffc9\042\uffc9\043\uffc9\044\uffc9\001\002\000" +
    "\004\040\164\001\002\000\020\006\uffac\013\uffac\014\uffac" +
    "\016\uffac\020\uffac\033\uffac\034\uffac\001\002\000\014\022" +
    "\151\036\166\042\147\043\150\044\146\001\002\000\022" +
    "\022\uffc2\027\uffc2\036\uffc2\037\uffc2\040\uffc2\042\uffc2\043" +
    "\uffc2\044\uffc2\001\002\000\004\006\171\001\002\000\004" +
    "\045\uffb5\001\002\000\006\045\uffb4\047\172\001\002\000" +
    "\004\045\uffb3\001\002\000\016\004\133\006\132\015\130" +
    "\030\126\035\123\050\131\001\002\000\014\022\151\036" +
    "\175\042\147\043\150\044\146\001\002\000\004\026\176" +
    "\001\002\000\016\006\110\007\076\016\101\020\107\033" +
    "\111\034\104\001\002\000\004\040\205\001\002\000\020" +
    "\006\uffb0\013\uffb0\014\uffb0\016\uffb0\020\uffb0\033\uffb0\034" +
    "\uffb0\001\002\000\020\006\uffae\013\202\014\uffae\016\uffae" +
    "\020\uffae\033\uffae\034\uffae\001\002\000\016\006\110\007" +
    "\076\016\101\020\107\033\111\034\104\001\002\000\020" +
    "\006\uffb2\013\uffb2\014\uffb2\016\uffb2\020\uffb2\033\uffb2\034" +
    "\uffb2\001\002\000\020\006\uffaf\013\uffaf\014\uffaf\016\uffaf" +
    "\020\uffaf\033\uffaf\034\uffaf\001\002\000\020\006\uffb1\013" +
    "\uffb1\014\uffb1\016\uffb1\020\uffb1\033\uffb1\034\uffb1\001\002" +
    "\000\004\036\207\001\002\000\004\040\210\001\002\000" +
    "\020\006\uffab\013\uffab\014\uffab\016\uffab\020\uffab\033\uffab" +
    "\034\uffab\001\002\000\016\004\133\006\132\015\130\030" +
    "\126\035\123\050\131\001\002\000\014\022\151\040\213" +
    "\042\147\043\150\044\146\001\002\000\020\006\uffb7\013" +
    "\uffb7\014\uffb7\016\uffb7\020\uffb7\033\uffb7\034\uffb7\001\002" +
    "\000\004\006\215\001\002\000\004\045\216\001\002\000" +
    "\016\004\133\006\132\015\130\030\126\035\123\050\131" +
    "\001\002\000\014\022\151\027\220\042\147\043\150\044" +
    "\146\001\002\000\016\004\133\006\132\015\130\030\126" +
    "\035\123\050\131\001\002\000\014\022\151\036\222\042" +
    "\147\043\150\044\146\001\002\000\004\012\223\001\002" +
    "\000\016\006\110\007\076\016\101\020\107\033\111\034" +
    "\104\001\002\000\020\006\uffad\013\uffad\014\uffad\016\uffad" +
    "\020\uffad\033\uffad\034\uffad\001\002\000\004\035\054\001" +
    "\002\000\004\040\227\001\002\000\016\007\uffdc\011\uffdc" +
    "\017\uffdc\023\uffdc\031\uffdc\032\uffdc\001\002\000\016\007" +
    "\ufff4\011\015\017\ufff4\023\ufff4\031\021\032\013\001\002" +
    "\000\004\007\076\001\002\000\004\040\233\001\002\000" +
    "\010\007\uffdb\017\uffdb\023\uffdb\001\002\000\004\042\241" +
    "\001\002\000\016\006\234\007\ufff4\017\ufff4\023\ufff4\031" +
    "\021\032\013\001\002\000\016\006\ufff2\007\ufff2\017\ufff2" +
    "\023\ufff2\031\ufff2\032\ufff2\001\002\000\004\007\ufffc\001" +
    "\002\000\016\006\ufff3\007\ufff3\017\ufff3\023\ufff3\031\ufff3" +
    "\032\ufff3\001\002\000\010\004\246\015\245\030\244\001" +
    "\002\000\004\040\247\001\002\000\004\040\uffef\001\002" +
    "\000\004\040\uffee\001\002\000\004\040\uffed\001\002\000" +
    "\004\040\ufff0\001\002\000\016\006\ufff1\007\ufff1\017\ufff1" +
    "\023\ufff1\031\ufff1\032\ufff1\001\002\000\004\046\251\001" +
    "\002\000\004\002\ufffd\001\002\000\006\037\065\041\257" +
    "\001\002\000\012\006\055\007\ufff4\017\ufff4\023\ufff4\001" +
    "\002\000\012\006\uffe2\007\uffe2\017\uffe2\023\uffe2\001\002" +
    "\000\010\007\ufff8\017\051\023\047\001\002\000\012\006" +
    "\uffe3\007\uffe3\017\uffe3\023\uffe3\001\002\000\012\006\260" +
    "\010\042\021\040\047\041\001\002\000\004\040\uffdd\001" +
    "\002\000\004\040\uffde\001\002\000\004\040\263\001\002" +
    "\000\012\006\uffe1\007\uffe1\017\uffe1\023\uffe1\001\002\000" +
    "\004\002\001\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\262\000\006\002\003\050\004\001\001\000\002\001" +
    "\001\000\004\003\005\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\051\011\001\001\000" +
    "\012\004\013\010\017\011\016\012\015\001\001\000\010" +
    "\021\252\022\253\023\251\001\001\000\004\005\247\001" +
    "\001\000\006\013\234\014\235\001\001\000\006\030\047" +
    "\031\045\001\001\000\002\001\001\000\002\001\001\000" +
    "\006\017\023\020\022\001\001\000\002\001\001\000\002" +
    "\001\001\000\010\011\024\012\015\020\025\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\026\032\027\031\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\027\033\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\025\042\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\032\052\001\001\000\002\001\001\000\010\023" +
    "\055\033\056\034\057\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\006\023\055\034\063\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\025\066\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\025\071" +
    "\001\001\000\002\001\001\000\004\053\073\001\001\000" +
    "\012\004\074\010\017\011\016\012\015\001\001\000\004" +
    "\005\076\001\001\000\022\006\112\007\102\037\105\040" +
    "\101\041\115\042\114\044\104\045\111\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\020\007\117\037\105" +
    "\040\101\041\115\042\114\044\104\045\111\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\010\035" +
    "\124\041\133\046\123\001\001\000\006\035\164\041\133" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\010\035\137\036\140\041\133\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\006\035\144\041\133\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\035\154\041\133\001" +
    "\001\000\006\035\153\041\133\001\001\000\006\035\152" +
    "\041\133\001\001\000\006\035\151\041\133\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\006\035\173\041\133\001\001\000\002\001" +
    "\001\000\002\001\001\000\024\005\176\007\177\037\105" +
    "\040\101\041\115\042\114\043\200\044\104\045\111\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\047\202" +
    "\001\001\000\024\005\176\007\177\037\105\040\101\041" +
    "\115\042\114\043\203\044\104\045\111\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\006\035\211" +
    "\041\133\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\006\035\216\041\133" +
    "\001\001\000\002\001\001\000\006\035\220\041\133\001" +
    "\001\000\002\001\001\000\002\001\001\000\024\005\176" +
    "\007\177\037\105\040\101\041\115\042\114\043\223\044" +
    "\104\045\111\001\001\000\002\001\001\000\004\032\225" +
    "\001\001\000\002\001\001\000\004\052\227\001\001\000" +
    "\012\004\230\010\017\011\016\012\015\001\001\000\004" +
    "\005\231\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\012\010\236\011\016\012\015\014\237" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\015\241\016\242\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\010\012\254\022\255\023" +
    "\251\001\001\000\002\001\001\000\006\030\047\031\045" +
    "\001\001\000\002\001\001\000\006\024\261\025\260\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$parser$actions {


	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();
	
	//lista para almacenar cadenas de caracteres
	List<QuadrupleIF> listaCadenas = new ArrayList<QuadrupleIF>();


  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // parametro_write ::= 
            {
              Object RESULT =null;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- devuelve una expresion nula
		ScopeIF scope = scopeManager.getCurrentScope();
		ExpresionLiteralCadena expresionCadena = new ExpresionLiteralCadena(new TypeInteger(scope),"sin parametro");
		expresionCadena.setSinParametro();
		RESULT = expresionCadena;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametro_write",36, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // parametro_write ::= LITERAL_CADENA 
            {
              Object RESULT =null;
		int cadenaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cadenaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token cadena = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- devuelve una expresion de tipo INTEGER
		ScopeIF scope = scopeManager.getCurrentScope();
		ExpresionLiteralCadena expresionCadena = new ExpresionLiteralCadena(new TypeInteger(scope),cadena.getLexema());
		RESULT = expresionCadena;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametro_write",36, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // parametro_write ::= exp 
            {
              Object RESULT =null;
		int expresionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expresionright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp expresion = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		RESULT = expresion;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametro_write",36, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // sentencia_write ::= WRITELN PARENT_ABRIR PARENT_CERRAR PUNTO_Y_COMA 
            {
              Sentencia_write RESULT =null;
		
		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		String saltoLn = "\n";
		Sentencia_write sentenciaWriteLn = new Sentencia_write(true);
		sentenciaWriteLn.generateIntermediateCode();
		RESULT = sentenciaWriteLn;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_write",35, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // sentencia_write ::= WRITE PARENT_ABRIR parametro_write PARENT_CERRAR PUNTO_Y_COMA 
            {
              Sentencia_write RESULT =null;
		int linealeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int linearight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token linea = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int expresionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int expresionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object expresion = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		if(expresion != null) {
			TypeIF tipoExpresion = ((Exp) expresion).getType();
			// --- comprueba si el tipo del parametro write es de tipo INTEGER o POINTER, si no lo es produce un error
			if(!(tipoExpresion instanceof TypeInteger) ) {
				if(!(tipoExpresion instanceof TypePointer)) {
					semanticErrorManager.semanticFatalError("error 53: Parametro en sentencia write invalido. El tipo de la expresion no es integer o cadena [Linea: " + linea.getLine() + ". Columna: " + linea.getColumn() + ".] - Error semantico.");
				}
			}
		}
		
		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		Sentencia_write sentenciaWrite = null;
		if(expresion != null) {
			if ( !(expresion instanceof ExpresionLiteralCadena) ) {
				sentenciaWrite = new Sentencia_write( ((Exp)expresion) );
				sentenciaWrite.generateIntermediateCode();
			} else {
				if( ((ExpresionLiteralCadena)expresion).getTieneParametro()) {
					sentenciaWrite = new Sentencia_write( ((ExpresionLiteralCadena)expresion).getCadena());
					sentenciaWrite.generateIntermediateCode();
				} else {
					sentenciaWrite = new Sentencia_write(true);
					sentenciaWrite.generateIntermediateCode();
				}
			}
		}
		RESULT = sentenciaWrite;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_write",35, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // sentencia_for ::= FOR PARENT_ABRIR ID DOS_PUNTOS_IGUAL exp TO exp PARENT_CERRAR DO sentencias_then_else_for 
            {
              Sentencia_for RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-7)).value;
		int expresion1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int expresion1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Exp expresion1 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int expresion2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int expresion2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Exp expresion2 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int sentenciasleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentenciasright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencias_then_else_for sentencias = (Sentencias_then_else_for)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		String nombre = id.getLexemaUpperCase();
		SymbolIF simboloId = null;
		// --- comprueba si esta declarado el identificador del indice for, si no lo esta produce un error
		if(!scopeManager.containsSymbol(nombre)) {
			semanticErrorManager.semanticFatalError("error 49: Nombre de indice invalido. ID no declarado. [Lexema: " + nombre + ". Linea: " + id.getLine() + ". Columna: " + id.getColumn() + ".] - Error semantico.");
		} else {
			simboloId = scopeManager.searchSymbol(nombre);
			TypeIF tipo = simboloId.getType();
			// --- comprueba si el indice es una variable o un parametro, si no lo es produce un error
			if(!(simboloId instanceof SymbolVariable) && !(simboloId instanceof SymbolParameter)) {
				semanticErrorManager.semanticFatalError("error 50: Nombre de indice invalido. El ID no es parametro ni variable [Lexema: " + nombre + ". Linea: " + id.getLine() + ". Columna: " + id.getColumn() + ".] - Error semantico.");
			} else {
				// --- comprueba si el tipo del indice es INTEGER, si no lo es produce un error
				if(!(tipo instanceof TypeInteger)) {
					semanticErrorManager.semanticFatalError("error 51: Indice invalido. El tipo de datos del ID no es integer. [Lexema: " + nombre + ". Linea: " + id.getLine() + ". Columna: " + id.getColumn() + ".] - Error semantico.");
				} else {
					// --- obtiene los tipos de las expresiones inicial y final asignadas al indice
					TypeIF tipoExpresion1 = expresion1.getType();
					TypeIF tipoExpresion2 = expresion2.getType();
					// --- comprueba si los tipos de las expresiones asignadas al indice son de tipo INTEGER, si no lo son produce un error
					if(!(tipoExpresion1 instanceof TypeInteger) || !(tipoExpresion2 instanceof TypeInteger)) {
						semanticErrorManager.semanticFatalError("error 52: Expresion/es asignadas al indice invalia/s. El tipo de datos de la/s expresion/es asignada/s al indice no es integer. [Lexema: " + nombre + ". Linea: " + id.getLine() + ". Columna: " + id.getColumn() + ".] - Error semantico.");
					}
				}
			}
		}

		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		Variable var = new Variable(nombre,simboloId.getScope());
		Sentencia_for sentenciaFor = new Sentencia_for();
		sentenciaFor.generateIntermediateCode(var, expresion1, expresion2, sentencias);
		RESULT = sentenciaFor;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_for",34, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // parte_else ::= 
            {
              Object RESULT =null;
		
		Sentencias_then_else_for sentenciasTEF = new Sentencias_then_else_for();
		RESULT = sentenciasTEF;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parte_else",37, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // parte_else ::= ELSE sentencias_then_else_for 
            {
              Object RESULT =null;
		int sentenciasTEFleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentenciasTEFright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencias_then_else_for sentenciasTEF = (Sentencias_then_else_for)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		RESULT = sentenciasTEF;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parte_else",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // sentencias_then_else_for ::= sentencia 
            {
              Sentencias_then_else_for RESULT =null;
		int sentleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencia sent = (Sentencia)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		Sentencias_then_else_for sentenciasTEF = new Sentencias_then_else_for();
		sentenciasTEF.generateIntermediateCode(sent);
		RESULT = sentenciasTEF;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias_then_else_for",33, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // sentencias_then_else_for ::= bloque PUNTO_Y_COMA 
            {
              Sentencias_then_else_for RESULT =null;
		int bloqleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int bloqright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Bloque bloq = (Bloque)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		Sentencias_then_else_for sentenciasTEF = new Sentencias_then_else_for();
		sentenciasTEF.generateIntermediateCode(bloq);
		RESULT = sentenciasTEF;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias_then_else_for",33, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // sentencia_if ::= IF PARENT_ABRIR exp PARENT_CERRAR THEN sentencias_then_else_for parte_else 
            {
              Sentencia_if RESULT =null;
		int linealeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int linearight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Token linea = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int expresionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int expresionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Exp expresion = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int sentencias1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sentencias1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Sentencias_then_else_for sentencias1 = (Sentencias_then_else_for)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int sentencias2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentencias2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object sentencias2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- obtiene el tipo de la expresion a evaluar
		TypeIF tipoExpresion = expresion.getType();
		// --- comprueba si la expresion a evaluar es de tipo BOOLEAN, si no lo es produce un error
		if(!(tipoExpresion instanceof TypeBoolean)) {
			semanticErrorManager.semanticFatalError("error 48: Expresion de evaluacion condicional IF invalida. La expresion no es booleana. [Linea: " + linea.getLine() + ". Columna: " + linea.getColumn() + ".] - Error semantico.");
		}

		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		Sentencia_if sentenciaIf = new Sentencia_if();
		sentenciaIf.generateIntermediateCode(expresion, sentencias1, ((Sentencia) sentencias2));
		RESULT = sentenciaIf;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_if",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // sentencia_asignacion_izq ::= ID PUNTO ID CIRCUNFLEJO 
            {
              Sentencia_asignacion_izq RESULT =null;
		int id1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int id1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id1 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int id2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int id2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id2 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- obtiene el nombre de registro y el nombre del campo de registro
		String nombreRegistro = id1.getLexemaUpperCase();
		String nombreCampoRegistro = id2.getLexemaUpperCase();
		int desplazamiento=0;
		// --- comprueba si el registro esta declarado, si no lo esta produce un error
		if(!scopeManager.containsSymbol(nombreRegistro)) {
			semanticErrorManager.semanticFatalError("error 44: Nombre de registro invalido. ID no declarado. [Lexema: " + nombreRegistro + ". Linea: " + id1.getLine() + ". Columna: " + id1.getColumn() + ".] - Error fatal.");
		} else {
			SymbolIF simboloIdRegistro = scopeManager.searchSymbol(nombreRegistro);
			TypeIF tipoRegistro = simboloIdRegistro.getType();
			// --- comprueba si el simbolo del registro es del tipo SymbolVariable, si no lo es produce un error
			if(!(simboloIdRegistro instanceof SymbolVariable)) {
				semanticErrorManager.semanticFatalError("error 45: Nombre de registro invalido. El ID no es una variable. [Lexema: " + nombreRegistro + ". Linea: " + id1.getLine() + ". Columna: " + id1.getColumn() + ".] - Error fatal.");
			} else {
				// --- comprueba si el tipo del registro es TypeRecord, si no lo es produce un error
				if(!(tipoRegistro instanceof TypeRecord)) {
					semanticErrorManager.semanticFatalError("error 46: Nombre de registro invalido. El ID no es de tipo Record. [Lexema: " + nombreRegistro + ". Linea: " + id1.getLine() + ". Columna: " + id1.getColumn() + ".] - Error fatal.");
				} else {
					// --- comprueba si existe el campo de registro en el registro declarado, si no existe produce un error
					if(!( ((TypeRecord)tipoRegistro).contieneCampoRegistro(nombreCampoRegistro))) {
						semanticErrorManager.semanticFatalError("error 47: Nombre de campo de registro invalido. No existe el campo de registro. [Lexema: " + nombreRegistro + "." + nombreCampoRegistro + ". Linea: " + id2.getLine() + ". Columna: " + id2.getColumn() + ".] - Error semantico.");
					} else {
						// --- crea una nueva sentencia de asignacion izq
						TypeIF tipoCampoRegistro = ((TypeRecord)tipoRegistro).tipoCampoRegistro(nombreCampoRegistro);
						Sentencia_asignacion_izq sentenciaAsignacionIzq = new Sentencia_asignacion_izq(nombreRegistro,simboloIdRegistro,tipoRegistro,id1.getLine(),"ID.ID^");
						sentenciaAsignacionIzq.setNombreCampoRegistro(nombreCampoRegistro);
						sentenciaAsignacionIzq.setTipoCampoRegistro(tipoCampoRegistro);
						desplazamiento = ((TypeRecord)tipoRegistro).desplazamientoCampoRegistro(nombreCampoRegistro);
						sentenciaAsignacionIzq.setDesplazamineto(desplazamiento);
						RESULT = sentenciaAsignacionIzq;
					}
				}
			}
		}
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_asignacion_izq",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // sentencia_asignacion_izq ::= ID PUNTO ID 
            {
              Sentencia_asignacion_izq RESULT =null;
		int id1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int id1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id1 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int id2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int id2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id2 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- obtiene el nombre del registro y el nombre del campo de registro
		String nombreRegistro = id1.getLexemaUpperCase();
		String nombreCampoRegistro = id2.getLexemaUpperCase();
		int desplazamiento=0;
		// --- comprueba si el nombre del registro esta declarado, si no lo esta produce un error
		if(!scopeManager.containsSymbol(nombreRegistro)) {
			semanticErrorManager.semanticFatalError("error 40: Nombre de registro invalido. ID no declarado. [Lexema: " + nombreRegistro + ". Linea: " + id1.getLine() + ". Columna: " + id1.getColumn() + ".] - Error fatal.");
		} else {
			SymbolIF simboloIdRegistro = scopeManager.searchSymbol(nombreRegistro);
			TypeIF tipoRegistro = simboloIdRegistro.getType();
			// --- comprueba si el identificador del registro es un simbolo variable, si no lo es produce un error
			if(!(simboloIdRegistro instanceof SymbolVariable)) {
				semanticErrorManager.semanticFatalError("error 41: Nombre de registro invalido. El ID no es una variable. [Lexema: " + nombreRegistro + ". Linea: " + id1.getLine() + ". Columna: " + id1.getColumn() + ".] - Error fatal.");
			} else {
				// --- comprueba si el tipo del identificador de registro es TypeRecord, si no lo es produce un error
				if(!(tipoRegistro instanceof TypeRecord)) {
					semanticErrorManager.semanticFatalError("error 42: Nombre de registro invalido. El ID no es de tipo Record. [Lexema: " + nombreRegistro + ". Linea: " + id1.getLine() + ". Columna: " + id1.getColumn() + ".] - Error fatal.");
				} else {
					// --- comprueba si el campo de registro existe en el registro declarado, si no existe produce un error
					if(!( ((TypeRecord)tipoRegistro).contieneCampoRegistro(nombreCampoRegistro))) {
						semanticErrorManager.semanticFatalError("error 43: Nombre de campo de registro invalido. No existe el campo de registro. [Lexema: " + nombreRegistro + "." + nombreCampoRegistro + ". Linea: " + id2.getLine() + ". Columna: " + id2.getColumn() + ".] - Error semantico.");
					} else {
						// --- crea una nueva sentencia de asignacion izq
						TypeIF tipoCampoRegistro = ((TypeRecord)tipoRegistro).tipoCampoRegistro(nombreCampoRegistro);
						Sentencia_asignacion_izq sentenciaAsignacionIzq = new Sentencia_asignacion_izq(nombreRegistro,simboloIdRegistro,tipoRegistro,id1.getLine(),"ID.ID");
						sentenciaAsignacionIzq.setNombreCampoRegistro(nombreCampoRegistro);
						sentenciaAsignacionIzq.setTipoCampoRegistro(tipoCampoRegistro);
						desplazamiento = ((TypeRecord)tipoRegistro).desplazamientoCampoRegistro(nombreCampoRegistro);
						sentenciaAsignacionIzq.setDesplazamineto(desplazamiento);
						RESULT = sentenciaAsignacionIzq;
					}
				}
			}
		}
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_asignacion_izq",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // sentencia_asignacion_izq ::= ID CIRCUNFLEJO 
            {
              Sentencia_asignacion_izq RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		String nombre = id.getLexemaUpperCase();
		// --- comprueba si el identificador esta declarado, si no lo esta produce un error
		if(!scopeManager.containsSymbol(nombre)) {
			semanticErrorManager.semanticFatalError("error 37: Nombre de identificador de puntero invalido. ID no declarado [Lexema: " + nombre + ". Linea: " + id.getLine() + ". Columna: " + id.getColumn() + ".] - Error fatal.");
		} else {
			SymbolIF simboloId = scopeManager.searchSymbol(nombre);
			TypeIF tipo = simboloId.getType();
			// --- comprueba si el identificador es una variable o parametro, si no lo es produce un error
			if(!(simboloId instanceof SymbolVariable) && !(simboloId instanceof SymbolParameter)) {
				semanticErrorManager.semanticFatalError("error 38: Nombre de identificador de puntero invalido. El ID no es un parametro o variable [Lexema: " + nombre + ". Linea: " + id.getLine() + ". Columna: " + id.getColumn() + ".] - Error fatal.");
			} else {
				// --- comprueba si el tipo del identificador es de tipo registro, si lo es produce un error
				if(tipo instanceof TypeRecord) {
					semanticErrorManager.semanticFatalError("error 39: Nombre de identificador de puntero invalido. El ID no puede ser de tipo Record [Lexema: " + nombre + ". Linea: " + id.getLine() + ". Columna: " + id.getColumn() + ".] - Error fatal.");
				} else {
					// --- crea una nueva sentencia de asignacion izq
					Sentencia_asignacion_izq sentenciaAsignacionIzq = new Sentencia_asignacion_izq(nombre,simboloId,tipo,id.getLine(),"ID^");
					RESULT = sentenciaAsignacionIzq;
				}
			}
		}
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_asignacion_izq",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // sentencia_asignacion_izq ::= ID 
            {
              Sentencia_asignacion_izq RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		String nombre = id.getLexemaUpperCase();
		// --- comprueba si el identificador esta declarado, si no lo esta produce un error
		if(!scopeManager.containsSymbol(nombre)) {
			semanticErrorManager.semanticFatalError("error 34: Identificador de la referencia de la asignacion invalido. ID no declarado. [Lexema: " + nombre + ". Linea: " + id.getLine() + ". Columna: " + id.getColumn() + ".] - Error semantico.");
		} else {
			SymbolIF simboloId = scopeManager.searchSymbol(nombre);
			TypeIF tipo = simboloId.getType();
			// --- comprueba si el identificador es un parametro o una variable, si no lo es produce un error
			if(!(simboloId instanceof SymbolVariable) && !(simboloId instanceof SymbolParameter) && !(simboloId instanceof SymbolVariableRetorno)) {
				semanticErrorManager.semanticFatalError("error 35: Identificador de la referencia de la asignacion invalido. La referencia no es un parametro o variable [Lexema: " + nombre + ". Linea: " + id.getLine() + ". Columna: " + id.getColumn() + ".] - Error semantico.");
			} else {
				// --- comprueba si el tipo del identificador es de tipo registro, si lo es produce un error
				if(tipo instanceof TypeRecord) {
					semanticErrorManager.semanticFatalError("error 36: Identificador de la referencia de la asignacion invalido. El ID no puede ser de tipo Record. [Lexema: " + nombre + ". Linea: " + id.getLine() + ". Columna: " + id.getColumn() + ".] - Error semantico.");
				} else {
					// --- crea una nueva sentencia de asignacion izq
					Sentencia_asignacion_izq sentenciaAsignacionIzq = new Sentencia_asignacion_izq(nombre,simboloId,tipo,id.getLine(),"ID");
					RESULT = sentenciaAsignacionIzq;
				}
			}
		}
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_asignacion_izq",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // sentencia_asignacion ::= sentencia_asignacion_izq DOS_PUNTOS_IGUAL exp PUNTO_Y_COMA 
            {
              Sentencia_asignacion RESULT =null;
		int referencialeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int referenciaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Sentencia_asignacion_izq referencia = (Sentencia_asignacion_izq)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token op = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int expresionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int expresionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Exp expresion = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- crea una nueva sentencia de asignacion
		String nombre = referencia.getNombre();
		Sentencia_asignacion sentenciaAsignacion = new Sentencia_asignacion(nombre);
		TypeIF tipoReferencia=null;
		// --- obtiene el tipo de la expresion
		TypeIF tipoExpresion = expresion.getType();
		// --- comprueba si la referencia de la asignacion es de tipo registro
		// --- si es de tipo registro, obtiene el tipo del campo, si no lo es, obtiene el tipo de la referencia
		if(referencia.getTipo() instanceof TypeRecord) {
			tipoReferencia = referencia.getTipoCampoRegistro();
		} else {
			tipoReferencia = referencia.getTipo();
		}
		// --- comprueba si el tipo de la referencia es compatible con el tipo de la expresion que se le asigna, si no lo es produce un error
		if(!sentenciaAsignacion.tiposCompatibles(tipoReferencia,tipoExpresion)) {
			semanticErrorManager.semanticFatalError("error 33: Tipos de datos incompatibles en asignacion. [Linea: " + op.getLine() + ". Columna: " + op.getColumn() + ".] - Error semantico.");
		}
		
		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		sentenciaAsignacion.generateIntermediateCode(referencia, expresion, nombre);
		RESULT = sentenciaAsignacion;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_asignacion",29, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // sentencia ::= sentencia_write 
            {
              Sentencia RESULT =null;
		int sentenciaWriteleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentenciaWriteright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencia_write sentenciaWrite = (Sentencia_write)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		//devuelve una sentencia write
		RESULT = sentenciaWrite;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // sentencia ::= llamada_subprograma PUNTO_Y_COMA 
            {
              Sentencia RESULT =null;
		int subprogramaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int subprogramaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		LLamada_subprograma subprograma = (LLamada_subprograma)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
		//devuelve una sentencia de asignacion vacia
		Sentencia_subprograma sentenciaSubprograma = new Sentencia_subprograma();
		String nombreSubprograma = subprograma.getIdSubprograma();

		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		sentenciaSubprograma.generateIntermediateCode(nombreSubprograma,subprograma);
		RESULT = sentenciaSubprograma;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // sentencia ::= sentencia_for 
            {
              Sentencia RESULT =null;
		int sentenciaForleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentenciaForright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencia_for sentenciaFor = (Sentencia_for)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		//devuelve una sentencia FOR
		RESULT = sentenciaFor;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // sentencia ::= sentencia_if 
            {
              Sentencia RESULT =null;
		int sentenciaIfleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentenciaIfright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencia_if sentenciaIf = (Sentencia_if)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		//devuelve una sentencia IF THEN ELSE
		RESULT = sentenciaIf;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // sentencia ::= sentencia_asignacion 
            {
              Sentencia RESULT =null;
		int sentenciaAsignacionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentenciaAsignacionright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencia_asignacion sentenciaAsignacion = (Sentencia_asignacion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		//devuelve la sentencia de asignacion
		RESULT = sentenciaAsignacion;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // secuencia_sentencias ::= sentencia 
            {
              Secuencia_sentencias RESULT =null;
		int sentleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencia sent = (Sentencia)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// --- crea una nueva secuencia de sentencias y le aade una nueva referencia
		Secuencia_sentencias secuenciaSentencias = new Secuencia_sentencias();
		secuenciaSentencias.addSentencia(sent);
		if(sent instanceof Sentencia_asignacion) {
			secuenciaSentencias.addReferencia( ((Sentencia_asignacion) sent).getReferencia());
		}
		
		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		ScopeIF scope = scopeManager.getCurrentScope();
		IntermediateCodeBuilder iCodeB = new IntermediateCodeBuilder(scope);
		iCodeB.addQuadruples(sent.getIntermediateCode());
		secuenciaSentencias.setIntermediateCode(iCodeB.create());
		RESULT = secuenciaSentencias;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("secuencia_sentencias",4, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // secuencia_sentencias ::= secuencia_sentencias sentencia 
            {
              Secuencia_sentencias RESULT =null;
		int secuenciaSentenciasleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int secuenciaSentenciasright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Secuencia_sentencias secuenciaSentencias = (Secuencia_sentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int sentleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencia sent = (Sentencia)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- aade una nueva referencia a la secuencia de sentencias
		secuenciaSentencias.addSentencia(sent);
		if(sent instanceof Sentencia_asignacion) {
			secuenciaSentencias.addReferencia( ((Sentencia_asignacion) sent).getReferencia());
		}
		
		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		ScopeIF scope = scopeManager.getCurrentScope();
		IntermediateCodeBuilder iCodeB = new IntermediateCodeBuilder(scope);
		iCodeB.addQuadruples(secuenciaSentencias.getIntermediateCode());
		iCodeB.addQuadruples(sent.getIntermediateCode());
		secuenciaSentencias.setIntermediateCode(iCodeB.create());
		RESULT = secuenciaSentencias;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("secuencia_sentencias",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // bloque ::= BEGIN END 
            {
              Bloque RESULT =null;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- crea un nuevo bloque vacio
		Bloque bloq = new Bloque();
		RESULT = bloq;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("bloque",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // bloque ::= BEGIN secuencia_sentencias END 
            {
              Bloque RESULT =null;
		int secuenciaSentenciasleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int secuenciaSentenciasright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Secuencia_sentencias secuenciaSentencias = (Secuencia_sentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- crea un nuevo bloque y le estable su secuencia de sentencias
		Bloque bloq = new Bloque();
		bloq.setSecuenciaSentencias( secuenciaSentencias);

		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		ScopeIF scope = scopeManager.getCurrentScope();
		IntermediateCodeBuilder iCodeB = new IntermediateCodeBuilder(scope);
		iCodeB.addQuadruples(secuenciaSentencias.getIntermediateCode());
		bloq.setIntermediateCode(iCodeB.create());
		RESULT = bloq;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("bloque",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // exp ::= llamada_subprograma 
            {
              Exp RESULT =null;
		int subprogramaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int subprogramaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		LLamada_subprograma subprograma = (LLamada_subprograma)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- obtiene el ambito actual
		ScopeIF scope = scopeManager.getCurrentScope();
		// --- obtiene el tipo, nombre, linea y columna del subprograma
		String tipoSubprograma = subprograma.getTipoSubprograma();
		String nombreSubprograma = subprograma.getIdSubprograma();
		int linea = subprograma.getLinea();
		int columna = subprograma.getColumna();
		ExpresionLLamadaSubprograma expresionLLSub=null;
		// --- comprueba si el subprograma es un procedimineto o una funcion
		// --- si el subprograma es un procedimiento produce un error, ya que los procedimientos no son expresiones
		if(tipoSubprograma.equals("PROCEDURE")) {
			semanticErrorManager.semanticFatalError("error 32: Llamada a subprograma invalida. Un procedimiento no se puede usar como una expresion. [Lexema: " + nombreSubprograma + ". Linea: " + linea + ". Columna: " + columna + ".] - Error semantico.");
		} else {
			// --- obtiene el tipo de retorno de la funcion y comprueba que tipo de datos es
			// --- crea una nueva expresion de llamada a subprograma con el tipo de retorno de la funcion
			TypeIF tipoR=subprograma.getTipoRetorno();
			if(tipoR instanceof TypeInteger) {
				expresionLLSub = new ExpresionLLamadaSubprograma(new TypeInteger(scope));
			}
			if(tipoR instanceof TypeBoolean) {
				expresionLLSub = new ExpresionLLamadaSubprograma(new TypeBoolean(scope));
			}
			if(tipoR instanceof TypePointer) {
				expresionLLSub = new ExpresionLLamadaSubprograma(new TypePointer(scope));
			}
		}
		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		expresionLLSub.generateIntermediateCode(nombreSubprograma,subprograma);
		RESULT = expresionLLSub;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp",27, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // exp ::= PARENT_ABRIR exp PARENT_CERRAR 
            {
              Exp RESULT =null;
		int expresionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int expresionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Exp expresion = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
		RESULT = expresion;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // exp ::= exp IGUAL exp 
            {
              Exp RESULT =null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp exp1 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token op = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp exp2 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		ScopeIF scope = scopeManager.getCurrentScope();
		// --- crea una nueva expresion logica IGUAL de tipo BOOLEAN
		ExpresionIgual expresionIgual = new ExpresionIgual(new TypeBoolean(scope));
		// --- comprueba si los tipos de las 2 expresiones de la operacion IGUAL son compatibles, si no lo son produce un error
		if(!expresionIgual.tiposCompatibles(exp1.getType(),exp2.getType())) {
			semanticErrorManager.semanticFatalError("error 31: Tipos de datos incompatibles en operacion '='. [Linea: " + op.getLine() + ". Columna: " + op.getColumn() + ".] - Error semantico.");
		}
		
		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		expresionIgual.generateIntermediateCode(exp1,exp2);
		RESULT = expresionIgual;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // exp ::= exp MAYOR_QUE exp 
            {
              Exp RESULT =null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp exp1 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token op = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp exp2 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		ScopeIF scope = scopeManager.getCurrentScope();
		// --- crea una nueva expresion logica MAYOR_QUE de tipo BOOLEAN
		ExpresionMayorQue expresionMayorQue = new ExpresionMayorQue(new TypeBoolean(scope));
		// --- comprueba si los tipos de las 2 expresiones de la operacion logica MAYOR_QUE son compatibles, si no lo son produce un error
		if(!expresionMayorQue.tiposCompatibles(exp1.getType(),exp2.getType())) {
			semanticErrorManager.semanticFatalError("error 30: Tipos de datos incompatibles en operacion '>'. [Linea: " + op.getLine() + ". Columna: " + op.getColumn() + ".] - Error semantico.");
		}
		
		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		expresionMayorQue.generateIntermediateCode(exp1,exp2);
		RESULT = expresionMayorQue;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // exp ::= exp OR exp 
            {
              Exp RESULT =null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp exp1 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token op = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp exp2 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		ScopeIF scope = scopeManager.getCurrentScope();
		// --- crea una nueva expresion logica OR de tipo BOOLEAN
		ExpresionOr expresionOr = new ExpresionOr(new TypeBoolean(scope));
		// --- comprueba si las 2 expresiones de la operacion logica OR son campatibles, si no lo son produce un errror
		if(!expresionOr.tiposCompatibles(exp1.getType(),exp2.getType())) {
			semanticErrorManager.semanticFatalError("error 29: Tipos de datos incompatibles en operacion OR. [Linea: " + op.getLine() + ". Columna: " + op.getColumn() + ".] - Error semantico.");
		}
		
		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		expresionOr.generateIntermediateCode(exp1,exp2);
		RESULT = expresionOr;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // exp ::= exp MENOS exp 
            {
              Exp RESULT =null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp exp1 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token op = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp exp2 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- crea una nueva expresion aritmetica MENOS de tipo INTEGER
		ScopeIF scope = scopeManager.getCurrentScope();
		ExpresionMenos expresionMenos = new ExpresionMenos(new TypeInteger(scope));
		// --- comprueba si los tipos de las 2 expresiones de la operacion MENOS son compatibles, si no lo son produce un error
		if(!expresionMenos.tiposCompatibles(exp1.getType(),exp2.getType())) {
			semanticErrorManager.semanticFatalError("error 28: Tipos de datos incompatibles en operacion resta. [Linea: " + op.getLine() + ". Columna: " + op.getColumn() + ".] - Error semantico.");
		}
		
		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		expresionMenos.generateIntermediateCode(exp1,exp2);
		RESULT = expresionMenos;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // exp ::= FALSE 
            {
              Exp RESULT =null;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token valor = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- crea una nueva expresion de tipo BOOLEAN
		ScopeIF scope = scopeManager.getCurrentScope();
		String svalor = valor.getLexemaUpperCase();
		boolean bvalor = Boolean.parseBoolean(svalor);
		ExpresionLogicaTrueFalse expresionFalse = new ExpresionLogicaTrueFalse(new TypeBoolean(scope), bvalor);
		
		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		expresionFalse.generateIntermediateCode();
		RESULT = expresionFalse;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp",27, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // exp ::= TRUE 
            {
              Exp RESULT =null;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token valor = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- crea una nueva expresion de tipo BOOLEAN
		ScopeIF scope = scopeManager.getCurrentScope();
		String svalor = valor.getLexemaUpperCase();
		boolean bvalor = Boolean.parseBoolean(svalor);
		ExpresionLogicaTrueFalse expresionTrue = new ExpresionLogicaTrueFalse(new TypeBoolean(scope), bvalor);
		
		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		expresionTrue.generateIntermediateCode();
		RESULT = expresionTrue;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp",27, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // exp ::= ARROBA ID PUNTO ID 
            {
              Exp RESULT =null;
		int idRegistroleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idRegistroright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token idRegistro = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idCampoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idCamporight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token idCampo = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		String nombreRegistro = idRegistro.getLexemaUpperCase();
		// --- comprueba si el registro esta declarado, si no lo esta produce un error
		if(!scopeManager.containsSymbol(nombreRegistro)) {
			semanticErrorManager.semanticFatalError("error 26: Nombre de registro invalido. ID no declarado. [Lexema: " + nombreRegistro + ". Linea: " + idRegistro.getLine() + ". Columna: " + idRegistro.getColumn() + ".] - Error fatal.");
		} 
		// --- obtiene el campo de registro
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolIF simboloRegistro = scopeManager.searchSymbol(nombreRegistro);
		TypeIF tipo = simboloRegistro.getType();
		TypeRecord tipoR = (TypeRecord)tipo;
		String nombreCR = idCampo.getLexemaUpperCase();
		// --- comprueba si existe el campo de registro en la secuencia de campos del registro declarado, si no existe produce un error
		if(!tipoR.contieneCampoRegistro(nombreCR)) {
			semanticErrorManager.semanticFatalError("error 27: Nombre de campo de registro invalido. El campo de registro no existe. [Lexema: " + nombreRegistro + "." + nombreCR + ". Linea: " + idCampo.getLine() + ". Columna: " + idCampo.getColumn() + ".] - Error semantico.");
		}
		// --- crea una nueva expresion de acceso a registro puntero @ de tipo INTEGER
		ExpresionAccesoRegistroPunteroArroba expresionAccesoRegistroPunteroArroba = new ExpresionAccesoRegistroPunteroArroba(new TypeInteger(scope));
		
		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		SymbolIF identificador = scopeManager.searchSymbol(nombreRegistro);
		int desplazamiento = expresionAccesoRegistroPunteroArroba.numCampo(tipoR,nombreCR) - 1;
		expresionAccesoRegistroPunteroArroba.generateIntermediateCode(identificador,nombreRegistro,desplazamiento);
		RESULT = expresionAccesoRegistroPunteroArroba;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // exp ::= ARROBA ID 
            {
              Exp RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		String nombre = id.getLexemaUpperCase();
		// --- comprueba si esta declarado el identificador, si no lo esta produce un error
		if(!scopeManager.containsSymbol(nombre)) {
			semanticErrorManager.semanticFatalError("error 25: Nombre de identificador invalido. ID no declarado. [Lexema: " + nombre + ". Linea: " + id.getLine() + ". Columna: " + id.getColumn() + ".] - Error fatal.");
		}
		// --- crea una nueva expresion puntero @ de tipo INTEGER
		ScopeIF scope = scopeManager.getCurrentScope();
		ExpresionPunteroArroba expresionPunteroArroba = new ExpresionPunteroArroba(new TypeInteger(scope));
				
		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		SymbolIF identificador = scopeManager.searchSymbol(nombre);
		expresionPunteroArroba.generateIntermediateCode(identificador,nombre);
		RESULT = expresionPunteroArroba;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // exp ::= ID PUNTO ID CIRCUNFLEJO 
            {
              Exp RESULT =null;
		int idRegistroleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idRegistroright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token idRegistro = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int idCampoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idCamporight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token idCampo = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		String nombreRegistro = idRegistro.getLexemaUpperCase();
		// --- comprueba si el registro esta declarado, si no lo esta produce un error
		if(!scopeManager.containsSymbol(nombreRegistro)) {
			semanticErrorManager.semanticFatalError("error 23: Nombre de registro invalido. El ID no esta declarado. [Lexema: " + nombreRegistro + ". Linea: " + idRegistro.getLine() + ". Columna: " + idRegistro.getColumn() + ".] - Error fatal.");
		} 
		// --- obtiene el nombre del campo de registro
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolIF simboloRegistro = scopeManager.searchSymbol(nombreRegistro);
		TypeIF tipo = simboloRegistro.getType();
		TypeRecord tipoR = (TypeRecord)tipo;
		String nombreCR = idCampo.getLexemaUpperCase();
		// --- comprueba si existe en la secuencia de campos de registro, el campo de registro, si no existe produce un error
		if(!tipoR.contieneCampoRegistro(nombreCR)) {
			semanticErrorManager.semanticFatalError("error 24: Nombre de campo de registro invalido. El camp de registro no existe. [Lexema: " + nombreRegistro + "." + nombreCR + ". Linea: " + idCampo.getLine() + ". Columna: " + idCampo.getColumn() + ".] - Error semantico.");
		}
		// --- crea una nueva expresio de acceso a campo de registro puntero con el tipo del campo de registro
		ExpresionAccesoRegistroPuntero expresionAccesoRegistroPuntero = new ExpresionAccesoRegistroPuntero(new TypePointer(scope));
		
		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		SymbolIF identificador = scopeManager.searchSymbol(nombreRegistro);
		int desplazamiento = expresionAccesoRegistroPuntero.numCampo(tipoR,nombreCR) - 1;
		expresionAccesoRegistroPuntero.generateIntermediateCode(identificador,nombreRegistro,desplazamiento);
		RESULT = expresionAccesoRegistroPuntero;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // exp ::= ID PUNTO ID 
            {
              Exp RESULT =null;
		int idRegistroleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idRegistroright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token idRegistro = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idCampoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idCamporight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token idCampo = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		String nombreRegistro = idRegistro.getLexemaUpperCase();
		// --- comprueba si el registro esta declarado, si no lo esta produce un error
		if(!scopeManager.containsSymbol(nombreRegistro)) {
			semanticErrorManager.semanticFatalError("error 21: Nombre de registro invalido. El ID no esta declarado. [Lexema: " + nombreRegistro + ". Linea: " + idRegistro.getLine() + ". Columna: " + idRegistro.getColumn() + ".] - Error fatal.");
		}
		// --- obtiene el nombre y tipo del identificador
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolIF simboloRegistro = scopeManager.searchSymbol(nombreRegistro);
		TypeIF tipo = simboloRegistro.getType();
		TypeRecord tipoR = (TypeRecord)tipo;
		// --- obtiene el nombre del campo de registro
		String nombreCR = idCampo.getLexemaUpperCase();
		// --- comprueba si el campo de registro existe en la secuencia de campos del registro declarado, si no existe produce un error
		if(!tipoR.contieneCampoRegistro(nombreCR)) {
			semanticErrorManager.semanticFatalError("error 22: Nombre de campo de registro invalido. El campo de registro no existe. [Lexema: " + nombreRegistro + "." + nombreCR + ". Linea: " + idCampo.getLine() + ". Columna: " + idCampo.getColumn() + ".] - Error semantico.");
		}
		// --- crea una nueva expresion de acceso a campo de registro con el tipo del campo de registro
		TypeIF tipoCR = tipoR.tipoCampoRegistro(nombreCR);
		ExpresionAccesoRegistro expresionAccesoRegistro = new ExpresionAccesoRegistro(tipoCR);

		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		SymbolIF identificador = scopeManager.searchSymbol(nombreRegistro);
		int desplazamiento = expresionAccesoRegistro.numCampo(tipoR,nombreCR) - 1;
		expresionAccesoRegistro.generateIntermediateCode(identificador,nombreRegistro,desplazamiento);
		RESULT = expresionAccesoRegistro;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // exp ::= ID CIRCUNFLEJO 
            {
              Exp RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		String nombre = id.getLexemaUpperCase();
		// --- comprueba si esta declarado el identificador, si no lo esta produce un error
		if(!scopeManager.containsSymbol(nombre)) {
			semanticErrorManager.semanticFatalError("error 20: Nombre de identificador de puntero invalido. El ID no esta declarado. [Lexema: " + nombre + ". Linea: " + id.getLine() + ". Columna: " + id.getColumn() + ".] - Error fatal.");
		}
		// --- obtiene el simbolo y tipo del identificador y crea una nueva expresion con el tipo del identificador
		SymbolIF simboloPuntero = scopeManager.searchSymbol(nombre);
		TypeIF tipo = simboloPuntero.getType();
		ExpresionPuntero expresionPuntero = new ExpresionPuntero(tipo, nombre);
	
		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		SymbolIF identificador = scopeManager.searchSymbol(nombre);
		expresionPuntero.generateIntermediateCode(identificador,nombre);
		RESULT = expresionPuntero;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // exp ::= ID 
            {
              Exp RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- comprueba si esta declarado el identificador, si no lo esta produce un error
		String nombre = id.getLexemaUpperCase();
		if(!scopeManager.containsSymbol(nombre)) {
			semanticErrorManager.semanticFatalError("error 19: Nombre de identificador invalido. El ID no esta declarado. [Lexema: " + nombre + ". Linea: " + id.getLine() + ". Columna: " + id.getColumn() + ".] - Error fatal.");
		}
		// --- busca el simbolo y tipo del identificador y crea una nueva expresion ID con el tipo del identificador
		SymbolIF simboloId = scopeManager.searchSymbol(nombre);
		TypeIF tipo = simboloId.getType();
		ExpresionID expresionId = new ExpresionID(tipo,nombre);
	
		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		SymbolIF identificador = scopeManager.searchSymbol(nombre);
		expresionId.generateIntermediateCode(identificador,nombre);
		RESULT = expresionId;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp",27, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // exp ::= LITERAL_ENTERO 
            {
              Exp RESULT =null;
		int valorLEleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valorLEright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token valorLE = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- obtiene el ambito actual
		ScopeIF scope = scopeManager.getCurrentScope();
		String svalorLE = valorLE.getLexemaUpperCase();
		int ivalorLE = Integer.parseInt(svalorLE);
		// --- crea una nueva expresion literal entero, de tipo entero
		ExpresionLiteralEntero expresionLE = new ExpresionLiteralEntero(new TypeInteger(scope), ivalorLE);
		
		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		expresionLE.generateIntermediateCode();
		RESULT = expresionLE;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp",27, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // secuencia_parametros_llamada ::= exp 
            {
              Secuencia_parametros_llamada RESULT =null;
		int parametroleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int parametroright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp parametro = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- crea una nueva secuencia de parametros de llamada y aade un nuevo parametro a la secuencia
		Secuencia_parametros_llamada secuenciaParametrosLL = new Secuencia_parametros_llamada();
		secuenciaParametrosLL.addParametro(parametro);
		RESULT = secuenciaParametrosLL;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("secuencia_parametros_llamada",28, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // secuencia_parametros_llamada ::= secuencia_parametros_llamada COMA exp 
            {
              Secuencia_parametros_llamada RESULT =null;
		int secuenciaParametrosLLleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int secuenciaParametrosLLright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Secuencia_parametros_llamada secuenciaParametrosLL = (Secuencia_parametros_llamada)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int parametroleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int parametroright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp parametro = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- aade un parametro a la secuencia de parametros de llamada
		secuenciaParametrosLL.addParametro(parametro);
		RESULT = secuenciaParametrosLL;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("secuencia_parametros_llamada",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // llamada_subprograma ::= ID PARENT_ABRIR PARENT_CERRAR 
            {
              LLamada_subprograma RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		String nombre = id.getLexemaUpperCase();
		TypeIF tipoRetorno=null;
		LLamada_subprograma subprograma = new LLamada_subprograma();
		Secuencia_parametros_llamada sinParametros = null;
		subprograma.setParametrosLLamada(sinParametros);
		// --- comprueba si el subprograma esta declarado, si no lo esta produce un error
		if(!scopeManager.containsSymbol(nombre) || !scopeManager.containsType(nombre)) {
			semanticErrorManager.semanticFatalError("error 17: Nombre de subprograma invalido. El ID de subprograma no esta declarado. [Lexema: " + nombre + ". Linea: " + id.getLine() + ". Columna: " + id.getColumn() + ".] - Error fatal.");
		} else {
			// --- obtiene el simbolo del subprograma, buscando en los ambitos abiertos, comenzando por el mas bajo(el actual)
			// --- y obtiene la lista de parametros formales del subprograma
			SymbolIF subprogramaDcl = scopeManager.searchSymbol(nombre);
			Secuencia_parametros parametrosFormales=null;
			// --- comprueba si el subprograma es una funcion o un procedimiento
			if(subprogramaDcl instanceof SymbolFunction) {
				// --- si el subprograma es una funcion obtiene sus parametros formales y el tipo de retorno
				parametrosFormales = ((SymbolFunction) subprogramaDcl).getParametros();
				tipoRetorno = ((SymbolFunction) subprogramaDcl).getTipoRetorno();
				subprograma.setTipoSubprograma("FUNCTION");
				subprograma.setTipoRetorno(tipoRetorno);
			} else {
				// --- si el subprograma es un procedimineto obtiene sus parametros formales
				parametrosFormales = ((SymbolProcedure) subprogramaDcl).getParametros();
				subprograma.setTipoSubprograma("PROCEDURE");
			}
			// --- comprueba si el numero de parametros formales es 0, si no lo es produce un error
			if(parametrosFormales.numParametros()==0) {
				subprograma.setIdSubprograma(id.getLexemaUpperCase());
			} else {
				semanticErrorManager.semanticFatalError("error 18: Parametro/os invalido/os. Los parametros no son correctos. [Lexema: " + nombre + ". Linea: " + id.getLine() + ".] - Error fatal.");
			}
		}
		RESULT = subprograma;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("llamada_subprograma",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // llamada_subprograma ::= ID PARENT_ABRIR secuencia_parametros_llamada PARENT_CERRAR 
            {
              LLamada_subprograma RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int secuenciaParametrosLLleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int secuenciaParametrosLLright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Secuencia_parametros_llamada secuenciaParametrosLL = (Secuencia_parametros_llamada)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		String nombre = id.getLexemaUpperCase();
		TypeIF tipoRetorno=null;
		LLamada_subprograma subprograma = new LLamada_subprograma();
		subprograma.setLinea(id.getLine());
		subprograma.setColumna(id.getColumn());
		subprograma.setParametrosLLamada(secuenciaParametrosLL);
		// --- comprueba si el subprograma esta declarado, si no lo esta produce un error
		if(!scopeManager.containsSymbol(nombre) || !scopeManager.containsType(nombre)) {
			semanticErrorManager.semanticFatalError("error 15: Nombre de subprograma invalido. ID de subprograma no declarado. [Lexema: " + nombre + ". Linea: " + id.getLine() + ". Columna: " + id.getColumn() + ".] - Error fatal.");
		} else {
			// --- obtiene el simbolo del subprograma, buscando en los ambitos abiertos, comenzando por el mas bajo(el actual)
			// --- y obtiene la lista de parametros formales del subprograma
			SymbolIF subprogramaDcl = scopeManager.searchSymbol(nombre);
			Secuencia_parametros parametrosFormales=null;
			// --- comprueba si el subprograma es una funcion o un procedimiento
			if(subprogramaDcl instanceof SymbolFunction) {
				// --- si el subprograma es una funcion, obtiene los parametros formales y el tipo de retorno
				parametrosFormales = ((SymbolFunction) subprogramaDcl).getParametros();
				tipoRetorno = ((SymbolFunction) subprogramaDcl).getTipoRetorno();
				subprograma.setTipoSubprograma("FUNCTION");
				subprograma.setTipoRetorno(tipoRetorno);
			} else {
				// --- si el subprograma es un procedimiento obtiene los parametros formales
				parametrosFormales = ((SymbolProcedure) subprogramaDcl).getParametros();
				subprograma.setTipoSubprograma("PROCEDURE");
			}
			// --- comprueba que los parametros de llamada coincidan con los parametros formales del subprograma
			// --- si no coinciden produce un error
			if( ((Secuencia_parametros_llamada) secuenciaParametrosLL).parametrosCorrectos(parametrosFormales)) {
				subprograma.setIdSubprograma(id.getLexemaUpperCase());
			} else {
				semanticErrorManager.semanticFatalError("error 16: Parametro/os invalido/os. Tipos de parametros incorrectos. [Lexema: " + nombre + ". Linea: " + id.getLine() + ".] - Error fatal.");
			}
		}
		
		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		ScopeIF scope = scopeManager.getCurrentScope();
		IntermediateCodeBuilder iCodeB = new IntermediateCodeBuilder(scope);
		iCodeB.addQuadruples(secuenciaParametrosLL.getIntermediateCode());
		subprograma.setIntermediateCode(iCodeB.create());
		
		RESULT = subprograma;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("llamada_subprograma",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // decl_funcion ::= FUNCTION ID decl_parametros DOS_PUNTOS tipo_primitivo PUNTO_Y_COMA NT$3 declaraciones bloque PUNTO_Y_COMA 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-8)).value;
		int listaParametrosleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).left;
		int listaParametrosright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).right;
		Object listaParametros = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-7)).value;
		int retornoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int retornoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Tipo_primitivo retorno = (Tipo_primitivo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int declaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int declaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Declaraciones decla = (Declaraciones)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bloqleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int bloqright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Bloque bloq = (Bloque)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- obiene la secuencia de sentencias de asignacion del bloque y comprueba la existencia de retorno de la funcion
		Secuencia_sentencias secuenciaSentencias = bloq.getSecuenciaSentencias();
		if(!secuenciaSentencias.contieneReferencia(id.getLexemaUpperCase())) {
			semanticErrorManager.semanticFatalError("error 14: Funcion sin sentencia de retorno [Lexema: " + id.getLexemaUpperCase() + ". Linea: " + id.getLine() + ". Columna: " + id.getColumn() + ".] - Error fatal.");
		}
		ScopeIF scope = scopeManager.getCurrentScope();
		scopeManager.closeScope();
		
		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		Decl_funcion declFuncion = new Decl_funcion();
		String nombre = id.getLexemaUpperCase();
		scope = scopeManager.getCurrentScope();
		SymbolTableIF tablaSimbolos = scope.getSymbolTable();
		SymbolIF simbolo = tablaSimbolos.getSymbol(nombre);
		Procedure funcion = new Procedure(nombre,scope);
		LabelIF label = funcion.getCodeLabel();
		int level = scope.getLevel();
		IntermediateCodeBuilder iCodeB = new IntermediateCodeBuilder(scope);
		iCodeB.addQuadruple("INL", label, new Value(level));
		iCodeB.addQuadruples(decla.getIntermediateCode());
		iCodeB.addQuadruples(bloq.getIntermediateCode());
		declFuncion.setIntermediateCode(iCodeB.create());
		
		RESULT = declFuncion;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decl_funcion",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // NT$3 ::= 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int listaParametrosleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int listaParametrosright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object listaParametros = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int retornoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int retornoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Tipo_primitivo retorno = (Tipo_primitivo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- obtiene el ambito actual y su tabla de simbolos y tipos
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolTableIF tablaSimbolos = scope.getSymbolTable();
		TypeTableIF tablaTipos = scope.getTypeTable();
		String nombre = id.getLexemaUpperCase();
		int linea = id.getLine();
		int columna = id.getColumn();
		// --- comprueba si la funcion ya esta declarada, en cuyo caso produce un error
		if(tablaSimbolos.containsSymbol(nombre) || tablaTipos.containsType(nombre)) {
			semanticErrorManager.semanticFatalError("error 11: Nombre de funcion invalido. ID ya declarado. [Lexema: " + nombre + ". Linea: " + linea + ". Columna: " + columna + ".] - Error fatal.");
		} else {
			// --- aade la funcion a la tabla de simbolos
			TypeFunction tipo = new TypeFunction(scope,nombre);
			SymbolFunction simboloFuncion = new SymbolFunction(scope,nombre,tipo);
			simboloFuncion.setParametros((Secuencia_parametros) listaParametros);
			simboloFuncion.setTipoRetorno(retorno.getType());
			tablaSimbolos.addSymbol(simboloFuncion);
			// --- aade la funcion a la tabla de tipos
			TypeFunction tipoFuncion = new TypeFunction(scope,nombre);
			tipoFuncion.setParametros((Secuencia_parametros) listaParametros);
			tipoFuncion.setTipoRetorno(retorno.getType());
			tablaTipos.addType(tipoFuncion);
			// --- crea un nuevo ambito para el procedimiento y obtiene la tabla de simbolos y tipos
			scopeManager.openScope(nombre);
			scope = scopeManager.getCurrentScope();
			tablaSimbolos = scope.getSymbolTable();
			tablaTipos = scope.getTypeTable();
			// --- aade a la tabla de tipos los tipos basicos del lenguaje
			TypeTableIF typeTable = scope.getTypeTable();
			TypeInteger tsEntero = new TypeInteger(scope);
			typeTable.addType("INTEGER",tsEntero);
			TypeBoolean tsLogico = new TypeBoolean(scope);
			typeTable.addType("BOOLEAN",tsLogico);
			TypePointer tsPuntero = new TypePointer(scope);
			typeTable.addType("POINTER",tsPuntero);
			// --- Comprueba que la variable de retorno es valida
			if(tablaSimbolos.containsSymbol(nombre) || tablaTipos.containsType(nombre)) {
				semanticErrorManager.semanticFatalError("error 12: Nombre de variable de retorno invalido. ID ya declarado. [Lexema: " + nombre + ". Linea: " + linea + ". Columna: " + columna + ".] - Error fatal.");
			} else {
				// --- crea la variable de retorno con el nombre de la funcion y la aade a la tabla de simbolos de la funcion
				SymbolVariableRetorno variableRetorno = new SymbolVariableRetorno(scope,nombre,retorno.getType());
				tablaSimbolos.addSymbol(variableRetorno);
				// --- obtiene la secuencia de parametros, comprueba uno a uno que son validos
				// --- y los aade a la tabla de simblos del ambito de la funcion
				int i=0;
				ParametroFormal parametro = null;
				TypeIF tipoParametro = null;
				Identificador identificador = null;
				for(i=0;i<((Secuencia_parametros) listaParametros).numParametros();i++) {
					parametro=((Secuencia_parametros) listaParametros).getParametro(i);
					tipoParametro=((Secuencia_parametros) listaParametros).getTipoParametro(i);
					nombre=parametro.getNombre();
					linea=parametro.getLinea();
					columna=parametro.getColumna();
					if(tablaSimbolos.containsSymbol(nombre) || tablaTipos.containsType(nombre)) {
						semanticErrorManager.semanticFatalError("error 13: Nombre de parametro invalido. ID ya declarado. [Lexema: " + nombre + ". Linea: " + linea + ". Columna: " + columna + ".] - Error fatal.");
					} else {
						// --- aade el parametro a la tabla de simbolos
						SymbolParameter simboloParametro = new SymbolParameter(scope,nombre,tipoParametro);
						tablaSimbolos.addSymbol(simboloParametro);
					}
				}	
				
			}
		}
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$3",41, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // parametro ::= secuencia_IDs DOS_PUNTOS tipo_primitivo 
            {
              Parametro RESULT =null;
		int secuenciaIdsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int secuenciaIdsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Secuencia_IDs secuenciaIds = (Secuencia_IDs)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tipoPleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tipoPright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Tipo_primitivo tipoP = (Tipo_primitivo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		Parametro parametro = new Parametro(secuenciaIds,tipoP);
		RESULT = parametro;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametro",26, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // secuencia_parametros ::= parametro 
            {
              Secuencia_parametros RESULT =null;
		int parametrosleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int parametrosright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Parametro parametros = (Parametro)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- crea una secuencia de parametros
		Secuencia_parametros secuenciaParametros = new Secuencia_parametros();
		// --- aade un parametro o lista de parametros a la secuencia de parametros
		Secuencia_IDs listaIdentificadores = parametros.getIdentificadores();
		int num_identificadores = listaIdentificadores.numIds();
		Tipo_primitivo tipo = parametros.getTipo();
		ParametroFormal parametroF = new ParametroFormal();
		int i=0;
		Identificador identificador_aux=null;
		for (i=0;i<num_identificadores;i++) {
			identificador_aux=listaIdentificadores.getId(i);
			secuenciaParametros.addParametro(identificador_aux.getNombre(),tipo,identificador_aux.getLinea(),identificador_aux.getColumna());
		}
		RESULT = secuenciaParametros;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("secuencia_parametros",25, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // secuencia_parametros ::= secuencia_parametros PUNTO_Y_COMA parametro 
            {
              Secuencia_parametros RESULT =null;
		int secuenciaParametrosleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int secuenciaParametrosright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Secuencia_parametros secuenciaParametros = (Secuencia_parametros)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int parametrosleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int parametrosright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Parametro parametros = (Parametro)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- aade un parametro o lista de parametros a la secuencia de parametros
		Secuencia_IDs listaIdentificadores = parametros.getIdentificadores();
		int num_identificadores = listaIdentificadores.numIds();
		Tipo_primitivo tipo = parametros.getTipo();
		ParametroFormal parametroF = new ParametroFormal();
		int i=0;
		Identificador identificador_aux=null;
		for (i=0;i<num_identificadores;i++) {
			identificador_aux=listaIdentificadores.getId(i);
			secuenciaParametros.addParametro(identificador_aux.getNombre(),tipo,identificador_aux.getLinea(),identificador_aux.getColumna());
		}
		RESULT = secuenciaParametros;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("secuencia_parametros",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // decl_parametros ::= PARENT_ABRIR PARENT_CERRAR 
            {
              Object RESULT =null;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- crea una secuencia de parametros vacia
		Secuencia_parametros secuenciaParametros = new Secuencia_parametros();
		RESULT = secuenciaParametros;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decl_parametros",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // decl_parametros ::= PARENT_ABRIR secuencia_parametros PARENT_CERRAR 
            {
              Object RESULT =null;
		int secuenciaParametrosleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int secuenciaParametrosright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Secuencia_parametros secuenciaParametros = (Secuencia_parametros)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		RESULT = secuenciaParametros;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decl_parametros",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // decl_procedimiento ::= PROCEDURE ID decl_parametros PUNTO_Y_COMA NT$2 declaraciones bloque PUNTO_Y_COMA 
            {
              Decl_procedimiento RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Decl_procedimiento) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int listaParametrosleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int listaParametrosright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Object listaParametros = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int declaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int declaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Declaraciones decla = (Declaraciones)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bloqleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int bloqright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Bloque bloq = (Bloque)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- cierra el ambito del procedimiento
		ScopeIF scope = scopeManager.getCurrentScope();
		int level = scope.getLevel();
		scopeManager.closeScope();
		
		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		Decl_procedimiento declProcedimiento = new Decl_procedimiento();
		String nombre = id.getLexemaUpperCase();
		scope = scopeManager.getCurrentScope();
		SymbolTableIF tablaSimbolos = scope.getSymbolTable();
		SymbolIF simbolo = tablaSimbolos.getSymbol(nombre);
		Procedure procedimiento = new Procedure(nombre,scope);
		LabelIF label = procedimiento.getCodeLabel();
		IntermediateCodeBuilder iCodeB = new IntermediateCodeBuilder(scope);
		iCodeB.addQuadruple("INL", label, new Value(level));
		iCodeB.addQuadruples(decla.getIntermediateCode());
		iCodeB.addQuadruples(bloq.getIntermediateCode());
		iCodeB.addQuadruple("RET",null,new Value(level));  //****
		declProcedimiento.setIntermediateCode(iCodeB.create());
		
		RESULT = declProcedimiento;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decl_procedimiento",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // NT$2 ::= 
            {
              Decl_procedimiento RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int listaParametrosleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int listaParametrosright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object listaParametros = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- obtiene el ambito actual y su tabla de simbolos y tipos
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolTableIF tablaSimbolos = scope.getSymbolTable();
		TypeTableIF tablaTipos = scope.getTypeTable();
		String nombre = id.getLexemaUpperCase();
		int linea = id.getLine();
		int columna = id.getColumn();
		// --- comprueba si el procedimiento ya esta declarado, en cuyo caso produce un error
		if(tablaSimbolos.containsSymbol(nombre) || tablaTipos.containsType(nombre)) {
			semanticErrorManager.semanticFatalError("error 09: Nombre de procedimiento invalido. ID ya declarado. [Lexema: " + nombre + ". Linea: " + linea + ". Columna: " + columna + ".] - Error fatal.");
		} else {
			// --- aade el procemiento a la tabla de simbolos
			TypeProcedure tipo = new TypeProcedure(scope,nombre);
			SymbolProcedure simboloProcedimiento = new SymbolProcedure(scope,nombre,tipo);
			simboloProcedimiento.setParametros((Secuencia_parametros) listaParametros);
			tablaSimbolos.addSymbol(simboloProcedimiento);
			// --- aade el procedimiento a la tabla de tipos
			TypeProcedure tipoProcedimiento = new TypeProcedure(scope,nombre);
			tipoProcedimiento.setParametros((Secuencia_parametros) listaParametros);
			tablaTipos.addType(tipoProcedimiento);
			// --- crea un nuevo ambito para el procedimiento y obtiene la tabla de simbolos y tipos
			scopeManager.openScope(nombre);
			scope = scopeManager.getCurrentScope();
			tablaSimbolos = scope.getSymbolTable();
			tablaTipos = scope.getTypeTable();
			// --- aade a la tabla de tipos los tipos basicos del lenguaje
			TypeTableIF typeTable = scope.getTypeTable();
			TypeInteger tsEntero = new TypeInteger(scope);
			typeTable.addType("INTEGER",tsEntero);
			TypeBoolean tsLogico = new TypeBoolean(scope);
			typeTable.addType("BOOLEAN",tsLogico);
			TypePointer tsPuntero = new TypePointer(scope);
			typeTable.addType("POINTER",tsPuntero);
			
			// --- obtiene la secuencia de parametros, comprueba uno a uno que son validos
			// --- y los aade a la tabla de simblos del ambito del procedimiento
			int i=0;
			ParametroFormal parametro = null;
			TypeIF tipoParametro = null;
			Identificador identificador = null;
			for(i=0;i<((Secuencia_parametros) listaParametros).numParametros();i++) {
				parametro=((Secuencia_parametros) listaParametros).getParametro(i);
				tipoParametro=((Secuencia_parametros) listaParametros).getTipoParametro(i);
				nombre=parametro.getNombre();
				linea=parametro.getLinea();
				columna=parametro.getColumna();
				if(tablaSimbolos.containsSymbol(nombre) || tablaTipos.containsType(nombre)) {
					semanticErrorManager.semanticFatalError("error 10: Nombre de parametro invalido. ID ya declarado. [Lexema: " + nombre + ". Linea: " + linea + ". Columna: " + columna + ".] - Error fatal.");
				} else {
					// --- aade el parametro a la tabla de simbolos
					SymbolParameter simboloParametro = new SymbolParameter(scope,nombre,tipoParametro);
					tablaSimbolos.addSymbol(simboloParametro);
				}	
			}
		}
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$2",40, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // tipo_datos ::= ID 
            {
              Tipo_datos RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- comprueba si ID esta en la tabla de tipos, si no lo esta produce un error
		String nombre = id.getLexemaUpperCase();
		if(scopeManager.containsType(nombre)) {
			Tipo_datos tipoD = new Tipo_datos();
			tipoD.setValor(nombre);
			RESULT = tipoD;
		} else {
			semanticErrorManager.semanticFatalError("error 08: Tipo de datos no definido. [Lexema: " + nombre + ". Linea: " + id.getLine() + ". Columna: " + id.getColumn() + ".] - Error fatal.");
		}
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipo_datos",18, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // tipo_datos ::= tipo_primitivo 
            {
              Tipo_datos RESULT =null;
		int tipoPleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tipoPright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Tipo_primitivo tipoP = (Tipo_primitivo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- crea un nuevo tipo de datos a partir de un tipo primitivo
		Tipo_datos tipoD = new Tipo_datos();
		tipoD.setValor(tipoP.getNombre());     
		RESULT = tipoD;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipo_datos",18, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // secuencia_IDs ::= ID 
            {
              Secuencia_IDs RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- crea una nueva secuencia de IDs y aade el identificador a la secuencia de IDs
		Secuencia_IDs secuenciaIds = new Secuencia_IDs();
		Identificador identificador = new Identificador(id.getLexemaUpperCase(),id.getLine(),id.getColumn());
		secuenciaIds.addId(identificador);
		RESULT = secuenciaIds;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("secuencia_IDs",17, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // secuencia_IDs ::= secuencia_IDs COMA ID 
            {
              Secuencia_IDs RESULT =null;
		int secuenciaIdsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int secuenciaIdsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Secuencia_IDs secuenciaIds = (Secuencia_IDs)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- aade el identificador a la secuencia de IDs
		Identificador identificador = new Identificador(id.getLexemaUpperCase(),id.getLine(),id.getColumn());
		secuenciaIds.addId(identificador);
		RESULT = secuenciaIds;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("secuencia_IDs",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // variabl ::= secuencia_IDs DOS_PUNTOS tipo_datos PUNTO_Y_COMA 
            {
              Variabl RESULT =null;
		int secuenciaIdsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int secuenciaIdsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Secuencia_IDs secuenciaIds = (Secuencia_IDs)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int tipoDleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tipoDright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Tipo_datos tipoD = (Tipo_datos)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
		Variabl variable = new Variabl(secuenciaIds,tipoD);
		RESULT = variable;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("variabl",16, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // secuencia_variables ::= variabl 
            {
              Object RESULT =null;
		int variableleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int variableright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Variabl variable = (Variabl)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- obtiene el ambito actual y su tabla de simbolos y tipos
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolTableIF tablaSimbolos = scope.getSymbolTable();
		TypeTableIF tablaTipos = scope.getTypeTable();
		// --- obtiene la secuencia de identificadores y su tipo
		TypeIF tipo = tablaTipos.getType(variable.getTipo().getValor());
		Secuencia_IDs secuenciaIDs = variable.getSecuenciaIDs();
		int i=0;
		int linea=0;
		int columna=0;
		String nombre=null;
		Identificador identificador=null;
		// --- recorre la secuencia de IDs uno a uno y comprueba si son validos y los aade a la tabla de simbolos
		for(i=0;i<secuenciaIDs.numIds();i++) {
			identificador=secuenciaIDs.getId(i);
			nombre = identificador.getNombre();
			linea = identificador.getLinea();
			columna = identificador.getColumna();
			// --- comprueba si el identificador esta en la tabla de simbolos o tipos, en cuyo caso produce un error
			if(tablaSimbolos.containsSymbol(nombre) || tablaTipos.containsType(nombre)) {
				semanticErrorManager.semanticFatalError("error 07: Nombre de variable invalido. El ID ya esta declarado. [Lexema: " + nombre + ". Linea: " + linea + ". Columna: " + columna + ".] - Error fatal.");
			} else {
				SymbolVariable simboloVariable = new SymbolVariable(scope,nombre,tipo);
				tablaSimbolos.addSymbol(simboloVariable);
			}
		}
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("secuencia_variables",15, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // secuencia_variables ::= secuencia_variables variabl 
            {
              Object RESULT =null;
		int variableleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int variableright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Variabl variable = (Variabl)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- obtiene el ambito actual y su tabla de simbolos y tipos
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolTableIF tablaSimbolos = scope.getSymbolTable();
		TypeTableIF tablaTipos = scope.getTypeTable();
		// --- obtiene la secuencia de identificadores y su tipo
		TypeIF tipo = tablaTipos.getType(variable.getTipo().getValor());
		Secuencia_IDs secuenciaIDs = variable.getSecuenciaIDs();
		int i=0;
		int linea=0;
		int columna=0;
		String nombre=null;
		Identificador identificador=null;
		// --- recorre la secuencia de IDs uno a uno y comprueba si son validos y los aade a la tabla de simbolos
		for(i=0;i<secuenciaIDs.numIds();i++) {
			identificador=secuenciaIDs.getId(i);
			nombre = identificador.getNombre();
			linea = identificador.getLinea();
			columna = identificador.getColumna();
			// --- comprueba si el identificador esta en la tabla de simbolos o tipos, en cuyo caso produce un error
			if(tablaSimbolos.containsSymbol(nombre) || tablaTipos.containsType(nombre)) {
				semanticErrorManager.semanticFatalError("error 06: Nombre de variable invalido. El ID ya esta declarado. [Lexema: " + nombre + ". Linea: " + linea + ". Columna: " + columna + ".] - Error fatal.");
			} else {
				SymbolVariable simboloVariable = new SymbolVariable(scope,nombre,tipo);
				tablaSimbolos.addSymbol(simboloVariable);
			}
		}
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("secuencia_variables",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // tipo_primitivo ::= CIRCUNFLEJO INTEGER 
            {
              Tipo_primitivo RESULT =null;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- crea un nuevo tipo primitivo POINTER
		ScopeIF scope = scopeManager.getCurrentScope();
		Tipo_primitivo tipoP = new Tipo_primitivo(new TypePointer(scope));
		RESULT = tipoP;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipo_primitivo",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // tipo_primitivo ::= BOOLEAN 
            {
              Tipo_primitivo RESULT =null;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token valor = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- crea un nuevo tipo primitivo BOOLEAN
		ScopeIF scope = scopeManager.getCurrentScope();
		Tipo_primitivo tipoP = new Tipo_primitivo(new TypeBoolean(scope));
		RESULT = tipoP;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipo_primitivo",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // tipo_primitivo ::= INTEGER 
            {
              Tipo_primitivo RESULT =null;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token valor = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- crea un nuevo tipo primitivo INTEGER
		ScopeIF scope = scopeManager.getCurrentScope();
		Tipo_primitivo tipoP = new Tipo_primitivo(new TypeInteger(scope));
		RESULT = tipoP;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipo_primitivo",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // campo_registro ::= ID DOS_PUNTOS tipo_primitivo PUNTO_Y_COMA 
            {
              Campo_registro RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int tipoPleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tipoPright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Tipo_primitivo tipoP = (Tipo_primitivo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- crea un nuevo campo de registro
		String nombre = id.getLexemaUpperCase();
		Tipo_primitivo tipo = tipoP;
		int linea = id.getLine();
		int columna = id.getColumn();
		Campo_registro campoR = new Campo_registro();
		campoR.setValor(nombre,tipo,linea,columna);
		RESULT = campoR;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("campo_registro",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // secuencia_campos_registro ::= campo_registro 
            {
              Secuencia_campos_registro RESULT =null;
		int campoRleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int campoRright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Campo_registro campoR = (Campo_registro)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- crea una nueva secuencia de campos de registro
		Secuencia_campos_registro secuenciaCamposR = new Secuencia_campos_registro();
		//comprueba si ya existe un campo_registro, en cuyo caso produce un error
		if(secuenciaCamposR.buscarCampoRegistro(campoR)){
			semanticErrorManager.semanticFatalError("error 05: Nombre de campo de registro invalido. Ya existe un campo de registro con ese nombre. [Lexema: " + campoR.getID() + ". Linea: " + campoR.getLinea() + ". Columna: " + campoR.getColumna() + ".] - Error fatal.");
		} else {
			//aade el nuevo campo de registro a la secuencia de campos de registro
			secuenciaCamposR.addCampoR(campoR);
		}
		RESULT = secuenciaCamposR;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("secuencia_campos_registro",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // secuencia_campos_registro ::= secuencia_campos_registro campo_registro 
            {
              Secuencia_campos_registro RESULT =null;
		int secuenciaCamposRleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int secuenciaCamposRright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Secuencia_campos_registro secuenciaCamposR = (Secuencia_campos_registro)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int campoRleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int campoRright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Campo_registro campoR = (Campo_registro)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- comprueba si ya existe un campo_registro, en cuyo caso produce un error
		if(secuenciaCamposR.buscarCampoRegistro(campoR)){
			semanticErrorManager.semanticFatalError("error 04: Nombre de campo de registro invalido. Ya existe un campo de registro con ese nombre. [Lexema: " + campoR.getID() + ". Linea: " + campoR.getLinea() + ". Columna: " + campoR.getColumna() + ".] - Error fatal.");
		} else {
			// --- aade el nuevo campo de registro a la secuencia de campos de registro
			secuenciaCamposR.addCampoR(campoR);
		}
		RESULT = secuenciaCamposR;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("secuencia_campos_registro",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // tipo ::= ID IGUAL RECORD secuencia_campos_registro END PUNTO_Y_COMA 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int secuenciaCamposRleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int secuenciaCamposRright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Secuencia_campos_registro secuenciaCamposR = (Secuencia_campos_registro)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- obtiene el ambito actual y su tabla de simbolos y tipos
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolTableIF tablaSimbolos = scope.getSymbolTable();
		TypeTableIF tablaTipos = scope.getTypeTable();
		String nombre = id.getLexemaUpperCase();
		// --- comprueba si el identificador esta declarado en cuyo caso produce un error
		if(tablaSimbolos.containsSymbol(nombre)) {
			semanticErrorManager.semanticFatalError("error 02: Nombre de registro invalido. ID ya declarado. [Lexema: " + nombre + ". Linea: " + id.getLine() + ". Columna: " + id.getColumn() + ".] - Error fatal.");
		} else {
			if(tablaTipos.containsType(nombre)) {
				semanticErrorManager.semanticFatalError("error 03: Nombre de registro invalido. Registro ya declarado. [Lexema: " + nombre + ". Linea: " + id.getLine() + ". Columna: " + id.getColumn() + ".] - Error fatal.");
			} else {
				// --- aade el nuevo tipo RECORD a la tabla de tipos
				TypeRecord tipoRegistro = new TypeRecord(scope,nombre);
				tipoRegistro.setValor(secuenciaCamposR.getSecuenciaCamposR());
				tablaTipos.addType(tipoRegistro);
			}
		}
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipo",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // secuencia_tipos ::= tipo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("secuencia_tipos",13, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // secuencia_tipos ::= secuencia_tipos tipo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("secuencia_tipos",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // literal_logico ::= FALSE 
            {
              Literal_logico RESULT =null;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token valor = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		Literal_logico literalLogico = new Literal_logico();
		literalLogico.setValor(valor.getLexemaUpperCase());
		RESULT = literalLogico;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("literal_logico",12, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // literal_logico ::= TRUE 
            {
              Literal_logico RESULT =null;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token valor = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		Literal_logico literalLogico = new Literal_logico();
		literalLogico.setValor(valor.getLexemaUpperCase());
		RESULT = literalLogico;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("literal_logico",12, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // literal_entero_o_logico ::= literal_logico 
            {
              Literal_entero_o_logico RESULT =null;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Literal_logico valor = (Literal_logico)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		Literal_entero_o_logico literalEL = new Literal_entero_o_logico();
		literalEL.setValor(valor.getValor());
		RESULT = literalEL;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("literal_entero_o_logico",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // literal_entero_o_logico ::= LITERAL_ENTERO 
            {
              Literal_entero_o_logico RESULT =null;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token valor = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		Literal_entero_o_logico literalEL = new Literal_entero_o_logico();
		literalEL.setValor(valor.getLexemaUpperCase());
		RESULT = literalEL;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("literal_entero_o_logico",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // constante ::= ID IGUAL literal_entero_o_logico PUNTO_Y_COMA 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int literalELleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int literalELright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Literal_entero_o_logico literalEL = (Literal_entero_o_logico)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- obtiene el ambito actual y su tabla de simbolos
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolTableIF tablaSimbolos = scope.getSymbolTable();
		String nombre = id.getLexemaUpperCase();
		// --- comprueba si el identificador esta declarado en cuyo caso produce un error
		if(tablaSimbolos.containsSymbol(nombre)) {
			semanticErrorManager.semanticFatalError("error 01: Nombre de constante invalido. ID ya declarado [Lexema: " + nombre + ". Linea: " + id.getLine() + ". Columna: " + id.getColumn() + ".] - Error fatal.");
		} else {
			TypeTableIF tablaTipos = scope.getTypeTable();
			TypeIF tipo=null;
			// --- comprueba si literal_entero_o_logico es de tipo INTEGER o BOOLEAN
			if(literalEL.getValor().equals("TRUE") || literalEL.getValor().equals("FALSE")) {
				tipo=new TypeBoolean(scope);
			} else {
				tipo=new TypeInteger(scope);
			}
			// --- aade la constante a la tabla de simbolos
			SymbolConstant simboloConstante = new SymbolConstant(scope,nombre,tipo);
			simboloConstante.setValor(literalEL.getValor());
			tablaSimbolos.addSymbol(simboloConstante);
		}
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("constante",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // secuencia_constantes ::= constante 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("secuencia_constantes",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // secuencia_constantes ::= secuencia_constantes constante 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("secuencia_constantes",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // decl_subprogramas ::= 
            {
              Object RESULT =null;
		
		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		Declaraciones declaraciones = new Declaraciones();
		ScopeIF scope = scopeManager.getCurrentScope();
		IntermediateCodeBuilder iCodeB = new IntermediateCodeBuilder(scope);
		declaraciones.setIntermediateCode(iCodeB.create());
		
		RESULT = declaraciones;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decl_subprogramas",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // decl_subprogramas ::= decl_subprogramas decl_funcion 
            {
              Object RESULT =null;
		int declSubprogramasleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int declSubprogramasright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object declSubprogramas = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int declFuncionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int declFuncionright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object declFuncion = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		Declaraciones declaraciones = new Declaraciones();
		ScopeIF scope = scopeManager.getCurrentScope();
		IntermediateCodeBuilder iCodeB = new IntermediateCodeBuilder(scope);
		
		iCodeB.addQuadruples(((Declaraciones) declSubprogramas).getIntermediateCode());
		iCodeB.addQuadruples(((Decl_funcion) declFuncion).getIntermediateCode());
		declaraciones.setIntermediateCode(iCodeB.create());
		
		RESULT = declaraciones;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decl_subprogramas",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // decl_subprogramas ::= decl_subprogramas decl_procedimiento 
            {
              Object RESULT =null;
		int declSubprogramasleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int declSubprogramasright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object declSubprogramas = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int declProcedimientoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int declProcedimientoright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Decl_procedimiento declProcedimiento = (Decl_procedimiento)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		Declaraciones declaraciones = new Declaraciones();
		ScopeIF scope = scopeManager.getCurrentScope();
		IntermediateCodeBuilder iCodeB = new IntermediateCodeBuilder(scope);
		
		iCodeB.addQuadruples(((Declaraciones) declSubprogramas).getIntermediateCode());
		iCodeB.addQuadruples(declProcedimiento.getIntermediateCode());
		declaraciones.setIntermediateCode(iCodeB.create());
		
		RESULT = declaraciones;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decl_subprogramas",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // decl_variables ::= decl_subprogramas 
            {
              Object RESULT =null;
		int declaracionesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int declaracionesright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object declaraciones = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		RESULT = declaraciones;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decl_variables",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // decl_variables ::= VAR secuencia_variables decl_subprogramas 
            {
              Object RESULT =null;
		int declaracionesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int declaracionesright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object declaraciones = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		RESULT = declaraciones;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decl_variables",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // decl_tipos ::= decl_variables 
            {
              Object RESULT =null;
		int declaracionesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int declaracionesright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object declaraciones = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		RESULT = declaraciones;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decl_tipos",6, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // decl_tipos ::= TYPE secuencia_tipos decl_variables 
            {
              Object RESULT =null;
		int declaracionesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int declaracionesright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object declaraciones = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		RESULT = declaraciones;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decl_tipos",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // declaraciones ::= decl_tipos 
            {
              Declaraciones RESULT =null;
		int declaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int declaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object decla = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		RESULT = (Declaraciones) decla;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaraciones",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // declaraciones ::= CONST secuencia_constantes decl_tipos 
            {
              Declaraciones RESULT =null;
		int declaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int declaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object decla = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		RESULT = (Declaraciones) decla;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaraciones",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // axiom ::= PROGRAM ID PUNTO_Y_COMA NT$1 declaraciones bloque PUNTO 
            {
              Axiom RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Axiom) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int declaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int declaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Declaraciones decla = (Declaraciones)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bloqleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int bloqright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Bloque bloq = (Bloque)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 	
		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		ScopeIF scope = scopeManager.getCurrentScope();
		LabelFactory lFact = new LabelFactory();
		LabelIF label = lFact.create(id.getLexemaUpperCase());
		int level = scope.getLevel();
		IntermediateCodeBuilder iCodeB = new IntermediateCodeBuilder(scope);
	
		iCodeB.addQuadruples(decla.getIntermediateCode());
		iCodeB.addQuadruple("INL", label, new Value(level));
		iCodeB.addQuadruples(bloq.getIntermediateCode());
		
		AxiomImp axiom = new AxiomImp();
		axiom.setLabel(label);
		axiom.setIntermediateCode(iCodeB.create());
		
		RESULT = axiom;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("axiom",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // NT$1 ::= 
            {
              Axiom RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
	
		// +++ *** +++ ANALISIS SEMANTICO +++ *** +++
		// --- crea el ambito inicial
		String nombre = id.getLexemaUpperCase();
		scopeManager.openScope(nombre);
		ScopeIF scope = scopeManager.getCurrentScope();

		// --- aade a la tabla de tipos los tipos basicos del lenguaje
		TypeTableIF typeTable = scope.getTypeTable();
		TypeInteger tsEntero = new TypeInteger(scope);
		typeTable.addType("INTEGER",tsEntero);
		TypeBoolean tsLogico = new TypeBoolean(scope);
		typeTable.addType("BOOLEAN",tsLogico);
		TypePointer tsPuntero = new TypePointer(scope);
		typeTable.addType("POINTER",tsPuntero);
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$1",39, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // program ::= NT$0 axiom 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int axleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int axright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Axiom ax = (Axiom)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
		// +++ *** CODIGO FINAL *** +++ 
		MemoryManager.mapAddresses();
		int nextCodeAddress = MemoryManager.getNextGlobalAddress();
		// +++ *** *** +++
		
  		// +++ *** +++ CODIGO INTERMEDIO +++ *** +++
		ScopeIF scope = scopeManager.getCurrentScope();
		IntermediateCodeBuilder iCodeB = new IntermediateCodeBuilder(scope);
		iCodeB.addQuadruple("INIT",new Value(nextCodeAddress),ax.getLabel());
		iCodeB.addQuadruples(ax.getIntermediateCode());
		iCodeB.addQuadruple("HALT");
		ax.setIntermediateCode(iCodeB.create());

		semanticErrorManager.semanticInfo("***************** CUADRUPLAS ****************** \n");
		List<QuadrupleIF> iCode=ax.getIntermediateCode();
		for(QuadrupleIF q : iCode) {
			semanticErrorManager.semanticInfo(q.toString() + "\n");
		}
		semanticErrorManager.semanticInfo("*********************************************** \n");
		
  		// No modificar esta estructura, aunque se pueden aadir ms acciones semnticas
  		// Para la entrega de febrero pueden comentarse las sentencias siguientes:
  				List intermediateCode = ax.getIntermediateCode ();
				finalCodeFactory.setEnvironment(CompilerContext.getExecutionEnvironment());
  				finalCodeFactory.create (intermediateCode);
  		// En caso de no comentarse las sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest y finalTest. Esto es debido a que 
  		// an no se tendr implementada la generacin de cdigo intermedio ni final.
  		// Para la entrega de junio y septiembre debern descomentarse y usarse.
        syntaxErrorManager.syntaxInfo ("Proceso parsing Terminado Correctamente."); 
        syntaxErrorManager.syntaxInfo (" "); 
		
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("program",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // NT$0 ::= 
            {
              Object RESULT =null;
 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$0",38, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

